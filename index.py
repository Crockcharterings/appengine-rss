#!/usr/bin/env pythonfrom google.appengine.api import usersimport webapp2from google.appengine.ext.webapp import templateimport modelsimport datetimeimport jsonimport loggingfrom google.appengine.api import urlfetchfrom xml.etree import ElementTree # XML parsingclass DefaultHandler(webapp2.RequestHandler):    def auth(self):        logged_in_user = users.get_current_user()        if logged_in_user:            # for Google accounts only (that's all we're using)            local_user = models.User.get_by_properties({"google_id": logged_in_user.user_id()})            # create new users implicitly            if local_user is None:                local_user = models.User(name = logged_in_user.nickname(), google_id = logged_in_user.user_id())                local_user.put()            self.user = local_user.key().id()            self.user_name = local_user.name            self.logout_url = users.create_logout_url("/")            return True        else:            self.response.write(template.render("login.html", {"login_url": users.create_login_url('/')}))            return False    def post(self):        self.get()class home(DefaultHandler):    def get(self):        if not self.auth():          return        args = {"user": self.user_name, "logout_url": self.logout_url}        self.response.out.write(template.render("index.html", args))class feeds(DefaultHandler):    def get(self):        if not self.auth():          return        r = models.Reading.all()        r.filter('user = ', self.user)        self.response.out.write(json.dumps({"feeds":[models.Feed.get_by_id(a.feed).json() for a in r]}))class reading_list(DefaultHandler):    def get(self):        if not self.auth():          return        unread = models.Unread.all()        feed = self.request.get('feed')        feed = int(feed) if feed != 'all' else feed        unread.filter('user = ', self.user)        articles = sorted([models.Article.get_by_id(u.article) for u in unread], key = lambda a: a.date)        articles = [a.key().id() for a in articles if feed == 'all' or a.feed == feed] # filter by feed        self.response.out.write(json.dumps({"articles":articles}))class unread(DefaultHandler):    def get(self):        if not self.auth():          return        unread = models.Unread.all()        unread.filter('user = ', self.user)        counts = {}        for u in unread:            a = models.Article.get_by_id(u.article)            counts[a.feed] = counts.get(a.feed, 0) + 1        for key in counts.keys():            f = models.Feed.get_by_id(key).title            counts[f] = counts[key]            del counts[key]        self.response.out.write(json.dumps({"counts":counts}))class article(DefaultHandler):    def get(self):        if not self.auth():          return        a = models.Article.get_by_id(int(self.request.get('article')))        self.response.out.write(json.dumps({"article":a.json()}))class read(DefaultHandler):    def get(self):        if not self.auth():          return        a = int(self.request.get('article'))        ur = models.Unread.get_by_properties({"user": self.user, "article": a})        if ur != None:          ur.delete()        self.response.out.write("Success")# if the feed already exists and/or the user is already reading it, this# returns the feed object as though nothing unusual happenedclass add(DefaultHandler):    def get(self):        if not self.auth():          return        feed_url = self.request.get('feed')        feed = models.Feed.get_by_properties({"url": feed_url})        if feed == None:            result = urlfetch.fetch(feed_url)            if result.status_code != 200:                raise Exception("Failed to fetch feed URL: " + feed.url)            # some elements may have a namespace prefix like {http://www.w3.org/2005/Atom}            root = ElementTree.fromstring(result.content)            if root.tag == "rss":              channel = root.find("channel")              feed = models.Feed(url = feed_url,                  title = channel.find("title").text,                  description = channel.find("description").text,                  language = (channel.find("language").text if channel.find("language") is not None else None), # not required                  link = channel.find("link").text)            else:              namespace = '{http://www.w3.org/2005/Atom}'              if root.tag == namespace+"feed":                atom = root                feed = models.Feed(url = feed_url,                    title = atom.find(namespace+"title").text,                    link = atom.find(namespace+"link").get("href"))            # check again to make sure we don't already have this feed            matching_feed = models.Feed.get_by_properties({"link": feed.link})            if matching_feed == None:              feed.put()            else:              feed = matching_feed        already_reading = models.Reading.get_by_properties({"user": self.user, "feed": feed.key().id()})        if not already_reading:          r = models.Reading(user = self.user, feed = feed.key().id())          r.put()        self.response.out.write(json.dumps(feed.json()))class remove(DefaultHandler):    def get(self):        if not self.auth():          return        r = models.Reading.get_by_properties({"user": self.user, "feed": int(self.request.get("feed"))})        if r != None:            #r.delete()            self.response.out.write("Success")        else:            self.response.out.write("Error: No such feed")class new_user(DefaultHandler):    def get(self):        if not self.auth():          return        name = self.request.get('name')        u = models.User.get_by_properties({"name": name})        if u != None:            u = models.User(name = name)            u.put()            self.response.out.write("Success")        else:            self.response.out.write("Taken")class star(DefaultHandler):    def get(self):        if not self.auth():          return        a = int(self.request.get('article'))        if models.Star.get_by_properties({"user": self.user, "article": a}) == None:            s = models.Star(user = self.user, article = a)            s.put()        self.response.out.write("Success")class unstar(DefaultHandler):    def get(self):        if not self.auth():          return        a = int(self.request.get('article'))        s = models.Star.get_by_properties({"user": self.user, "article": a})        if s != None:            s.delete()        self.response.out.write("Success")class starred(DefaultHandler):    def get(self):        if not self.auth():          return        stars = models.Star.all()        stars.filter("user", self.user)        articles = sorted([models.Article.get_by_id(s.article) for s in stars], key = lambda a: a.date)        articles = [a.key().id() for a in articles] # filter by feed        self.response.out.write(json.dumps({"articles":articles}))class manage_feeds(DefaultHandler):    def get(self):        if not self.auth():          return        args = {"user": self.user_name, "logout_url": self.logout_url}        self.response.out.write(template.render("feeds.html", args))app = webapp2.WSGIApplication([    ("/", home),    ("/feeds", feeds),    ("/list", reading_list),    ("/article", article),    ("/read", read),    ("/add", add),    ("/remove", remove),    ("/unread", unread),    ("/star", star),    ("/unstar", unstar),    ("/starred", starred),    ("/new_user", new_user),    ("/manage_feeds", manage_feeds),], debug = True)
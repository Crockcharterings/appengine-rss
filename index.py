#!/usr/bin/env pythonfrom google.appengine.ext import webappfrom google.appengine.ext.webapp import util, templateimport modelsimport datetimeimport jsonfrom google.appengine.api import urlfetchfrom xml.etree import ElementTree # XML parsing# Model -> JSON coder (http://stackoverflow.com/questions/1531501/json-serialization-of-google-app-engine-models)import timeSIMPLE_TYPES = (int, long, float, bool, dict, basestring, list)def toJSON(model):    output = {}    for key, prop in model.properties().iteritems():        value = getattr(model, key)        if value is None or isinstance(value, SIMPLE_TYPES):            output[key] = value        elif isinstance(value, datetime.date):            # Convert date/datetime to MILLISECONDS-since-epoch (JS "new Date()").            ms = time.mktime(value.utctimetuple()) * 1000            ms += getattr(value, 'microseconds', 0) / 1000            output[key] = int(ms)        elif isinstance(value, db.GeoPt):            output[key] = {'lat': value.lat, 'lon': value.lon}        elif isinstance(value, db.Model):            output[key] = to_dict(value)        else:            raise ValueError('cannot encode ' + repr(prop))    return outputdef get_user_id(u):    user = models.User.get_by_properties({"name": u})    return user.key().id()class home(webapp.RequestHandler):    def get(self):        args = {"param":[]}        self.response.out.write(template.render("index.html", args))    def post(self):        self.get()class feeds(webapp.RequestHandler):    def get(self):        r = models.Reading.all()        u = get_user_id(self.request.get('u'))        r.filter('user = ', u)        self.response.out.write(json.dumps({"feeds":[dict(toJSON(models.Feed.get_by_id(a.feed)).items() + {'id': a.feed}.items()) for a in r]}))    def post(self):        self.get()class reading_list(webapp.RequestHandler):    def get(self):        unread = models.Unread.all()        u = get_user_id(self.request.get('u'))        feed = self.request.get('feed')        feed = int(feed) if feed != 'all' else feed        unread.filter('user = ', u)        articles = sorted([models.Article.get_by_id(u.article) for u in unread], key = lambda a: a.date)        articles = [a.key().id() for a in articles if feed == 'all' or a.feed == feed] # filter by feed        self.response.out.write(json.dumps({"articles":articles}))    def post(self):        self.get()class unread(webapp.RequestHandler):    def get(self):        unread = models.Unread.all()        u = get_user_id(self.request.get('u'))        unread.filter('user = ', u)        counts = {}        for u in unread:            a = models.Article.get_by_id(u.article)            counts[a.feed] = counts.get(a.feed, 0) + 1        for key in counts.keys():            f = models.Feed.get_by_id(key).title            counts[f] = counts[key]            del counts[key]        self.response.out.write(json.dumps({"counts":counts}))    def post(self):        self.get()class article(webapp.RequestHandler):    def get(self):        a = models.Article.get_by_id(int(self.request.get('article')))        self.response.out.write(json.dumps({"article":toJSON(a)}))    def post(self):        self.get()class read(webapp.RequestHandler):    def get(self):        u = get_user_id(self.request.get('u'))        a = int(self.request.get('article'))        ur = models.Unread.get_by_properties({"user": u, "article": a})        if ur != None:          ur.delete()        self.response.out.write("Success")    def post(self):        self.get()class add(webapp.RequestHandler):    def get(self):        feed_url = self.request.get('feed')        feed = models.Feed.get_by_properties({"url": feed_url})        if feed != None:            result = urlfetch.fetch(feed_url)            if result.status_code != 200:                raise Exception("Failed to fetch feed URL: " + feed.url)            rss = ElementTree.fromstring(result.content)            channel = rss.find("channel")            feed = models.Feed(url = feed_url,                title = channel.find("title").text,                description = channel.find("description").text,                language = channel.find("language").text)            feed.put()        u = get_user_id(self.request.get('u'))        r = models.Reading(user = u, feed = feed.key().id())        r.put()        self.response.out.write("Success")    def post(self):        self.get()class remove(webapp.RequestHandler):    def get(self):        u = get_user_id(self.request.get('u'))        r = models.Reading.get_by_properties({"user", u, "feed", self.request.get("feed")})        if r != None:            r.delete()        self.response.out.write("Success")    def post(self):        self.get()class new_user(webapp.RequestHandler):    def get(self):        name = self.request.get('name')        u = models.User(name = name)        u.put()        self.response.out.write("Success")    def post(self):        self.get()class star(webapp.RequestHandler):    def get(self):        u = get_user_id(self.request.get('u'))        a = int(self.request.get('article'))        if models.Star.get_by_properties({"user": u, "article": a}) == None:            s = models.Star(user = u, article = a)            s.put()        self.response.out.write("Success")    def post(self):        self.get()class unstar(webapp.RequestHandler):    def get(self):        u = get_user_id(self.request.get('u'))        a = int(self.request.get('article'))        s = models.Star.get_by_properties({"user": u, "article": a})        if s != None:            s.delete()        self.response.out.write("Success")    def post(self):        self.get()class starred(webapp.RequestHandler):    def get(self):      u = get_user_id(self.request.get('u'))      stars = models.Star.all()      stars.filter("user", u)      articles = sorted([models.Article.get_by_id(s.article) for s in stars], key = lambda a: a.date)      articles = [a.key().id() for a in articles] # filter by feed      self.response.out.write(json.dumps({"articles":articles}))    def post(self):      self.get()def main():    app = webapp.WSGIApplication([("/", home),                                  ("/feeds", feeds),                                  ("/list", reading_list),                                  ("/article", article),                                  ("/read", read),                                  ("/add", add),                                  ("/remove", remove),                                  ("/unread", unread),                                  ("/star", star),                                  ("/starred", starred),                                  ("/new_user", new_user)                                 ])    util.run_wsgi_app(app)if __name__ == "__main__":    main()